# Copyright 2025 Antmicro
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""VC Static rules"""

load("@rules_hdl//common:providers.bzl", "LogInfo")
load("@rules_hdl//verilog:defs.bzl", "VerilogInfo")

_TCL_COMMON_SCRIPT = """
proc exit_on_violation {{ignore_severities "info"} {ignore_tags ""}} {
    set violation_tags [get_violation_tags]
    foreach tag $violation_tags {
    	set info [get_tag_info $tag]
        if {$tag in $ignore_tags} {
            continue
        }
        set severity [lindex $info 1]
        if {$severity in $ignore_severities} {
            continue
        }
        error "Violation found (tag: $tag, severity: $severity)"
    }
}
"""

def _value_to_tcl(value):
    if type(value) == "string":
        return "\"{}\"".format(value)
    elif type(value) == "int":
        return value
    elif type(value) == "bool":
        return str(value).lower()
    fail("Unsupported type convertion to TCL: {}".format(type(value)))

def _dict_to_tcl(dictionary):
    tcl = []
    for name, value in dictionary.items():
        definition = ["set", name]
        if type(value) == "list":
            definition.extend([_value_to_tcl(" ".join(value))])
        else:
            definition.append(_value_to_tcl(value))
        tcl.append(" ".join(definition))

    return "\n".join(tcl)

def _vc_static_lint(ctx):
    transitive_srcs = depset([], transitive = [ctx.attr.module[VerilogInfo].dag]).to_list()

    # Get flatten sources and headers
    all_srcs = [verilog_info_struct.srcs for verilog_info_struct in transitive_srcs]
    all_hdrs = [verilog_info_struct.hdrs for verilog_info_struct in transitive_srcs]

    all_srcs = [src for sub_tuple in all_srcs for src in sub_tuple]
    all_hdrs = [hdr for sub_tuple in all_hdrs for hdr in sub_tuple]

    log_file = ctx.actions.declare_file("{}.log".format(ctx.label.name))
    report_file = ctx.actions.declare_file("{}_report.txt".format(ctx.label.name))
    outputs = [log_file, report_file]

    tcl_variables = {
        "include_dirs": depset([f.dirname for f in (all_srcs + all_hdrs)]).to_list(),
        "report_file": report_file.path,
        "sources": [f.path for f in all_srcs],
        "top_module": ctx.attr.module_top,
    }

    # Write the TCL script
    tcl_script = ctx.actions.declare_file("{}.tcl".format(ctx.label.name))
    ctx.actions.expand_template(
        template = ctx.file.tcl_script,
        output = tcl_script,
        substitutions = {
            "#{{AUTOGENERATED_SCRIPT}}#": _dict_to_tcl(tcl_variables) + _TCL_COMMON_SCRIPT,
        },
    )

    vc_command = [
        "source",
        ctx.file.vc_static_env.path,
        "&&",
        "vc_static_shell",
        "-no_ui",
        "-no_restore",
        "-batch",
        "-output_log_file",
        log_file.path,
        "-file",
        tcl_script.path,
    ] + ctx.attr.opts

    ctx.actions.run_shell(
        outputs = outputs,
        inputs = [ctx.file.vc_static_env, tcl_script] + all_hdrs + all_srcs,
        progress_message = "Running VC Static: {}".format(ctx.label.name),
        command = " ".join(vc_command),
    )

    return [
        DefaultInfo(
            files = depset(outputs),
            runfiles = ctx.runfiles(files = []),
        ),
        LogInfo(
            files = [log_file],
        ),
    ]

vc_static_lint = rule(
    implementation = _vc_static_lint,
    attrs = {
        "module": attr.label(
            doc = "The top level module target to lint.",
            providers = [VerilogInfo],
            mandatory = True,
        ),
        "module_top": attr.string(
            doc = "The name of the top-level module in the design.",
            mandatory = True,
        ),
        "opts": attr.string_list(
            doc = "Additional command line options to pass to vc_static",
            default = [
                "-no_init",
                "-mode64",
                "-lic_wait",
                "1140",
            ],
        ),
        "tcl_script": attr.label(
            doc = "A TCL script run by VC Static",
            default = "//vc_static:default.tcl",
            allow_single_file = True,
        ),
        "vc_static_env": attr.label(
            doc = "A shell script to source the vc_static environment and " +
                  "point to license server",
            mandatory = True,
            allow_single_file = [".sh"],
        ),
    },
    provides = [
        DefaultInfo,
        LogInfo,
    ],
)
